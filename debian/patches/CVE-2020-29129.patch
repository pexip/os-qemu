While processing ARP/NCSI packets in 'arp_input' or 'ncsi_input'
routines, ensure that pkt_len is large enough to accommodate the
respective protocol headers, lest it should do an OOB access.
Add check to avoid it.

CVE-2020-29129 CVE-2020-29130
  QEMU: slirp: out-of-bounds access while processing ARP/NCSI packets
 -> https://www.openwall.com/lists/oss-security/2020/11/27/1

Reported-by: Qiuhao Li's avatarQiuhao Li <Qiuhao.Li@outlook.com>
Signed-off-by: default avatarPrasad J Pandit <pjp@fedoraproject.org>
Message-Id: <20201126135706.273950-1-ppandit@redhat.com>
Reviewed-by: default avatarMarc-Andr√© Lureau <marcandre.lureau@redhat.com>


--- qemu-3.1+dfsg.orig/slirp/ncsi.c
+++ qemu-3.1+dfsg/slirp/ncsi.c
@@ -122,6 +122,10 @@ void ncsi_input(Slirp *slirp, const uint
     uint32_t checksum;
     uint32_t *pchecksum;
 
+    if (pkt_len < ETH_HLEN + sizeof(struct ncsi_pkt_hdr)) {
+        return; /* packet too short */
+    }
+
     memset(ncsi_reply, 0, sizeof(ncsi_reply));
 
     memset(reh->h_dest, 0xff, ETH_ALEN);
--- qemu-3.1+dfsg.orig/slirp/slirp.c
+++ qemu-3.1+dfsg/slirp/slirp.c
@@ -793,6 +793,10 @@ static void arp_input(Slirp *slirp, cons
         return;
     }
 
+    if (pkt_len < ETH_HLEN + sizeof(struct slirp_arphdr)) {
+        return; /* packet too short */
+    }
+
     ar_op = ntohs(ah->ar_op);
     switch(ar_op) {
     case ARPOP_REQUEST:
