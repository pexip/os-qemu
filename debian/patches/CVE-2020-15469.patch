Origin: https://git.qemu.org/?p=qemu.git;a=commitdiff_plain;h=520f26fc6d17b71a43eaf620e834b3bdf316f3d3
Origin: https://git.qemu.org/?p=qemu.git;a=commitdiff_plain;h=24202d2b561c3b4c48bd28383c8c34b4ac66c2bf
Origin: https://git.qemu.org/?p=qemu.git;a=commitdiff_plain;h=921604e175b8ec06c39503310e7b3ec1e3eafe9e
Reviewed-by: Sylvain Beucler <beuc@debian.org>
Last-Update: 2021-02-12

From: Prasad J Pandit <pjp@fedoraproject.org>
Date: Tue, 11 Aug 2020 11:41:25 +0000 (+0530)
Subject: hw/pci-host: add pci-intack write method
X-Git-Url: https://git.qemu.org/?p=qemu.git;a=commitdiff_plain;h=520f26fc6d17b71a43eaf620e834b3bdf316f3d3

hw/pci-host: add pci-intack write method

Add pci-intack mmio write method to avoid NULL pointer dereference
issue.

Reported-by: Lei Sun <slei.casper@gmail.com>
Reviewed-by: Li Qiang <liq3ea@gmail.com>
Reviewed-by: Peter Maydell <peter.maydell@linaro.org>
Signed-off-by: Prasad J Pandit <pjp@fedoraproject.org>
Message-Id: <20200811114133.672647-2-ppandit@redhat.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
---
From: Prasad J Pandit <pjp@fedoraproject.org>
Date: Tue, 11 Aug 2020 11:41:27 +0000 (+0530)
Subject: vfio: add quirk device write method
X-Git-Url: https://git.qemu.org/?p=qemu.git;a=commitdiff_plain;h=24202d2b561c3b4c48bd28383c8c34b4ac66c2bf

vfio: add quirk device write method

Add vfio quirk device mmio write method to avoid NULL pointer
dereference issue.

Reported-by: Lei Sun <slei.casper@gmail.com>
Reviewed-by: Li Qiang <liq3ea@gmail.com>
Reviewed-by: Peter Maydell <peter.maydell@linaro.org>
Acked-by: Alex Williamson <alex.williamson@redhat.com>
Signed-off-by: Prasad J Pandit <pjp@fedoraproject.org>
Message-Id: <20200811114133.672647-4-ppandit@redhat.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
---
From: Prasad J Pandit <pjp@fedoraproject.org>
Date: Tue, 11 Aug 2020 11:41:30 +0000 (+0530)
Subject: spapr_pci: add spapr msi read method
X-Git-Url: https://git.qemu.org/?p=qemu.git;a=commitdiff_plain;h=921604e175b8ec06c39503310e7b3ec1e3eafe9e

spapr_pci: add spapr msi read method

Add spapr msi mmio read method to avoid NULL pointer dereference
issue.

Reported-by: Lei Sun <slei.casper@gmail.com>
Acked-by: David Gibson <david@gibson.dropbear.id.au>
Reviewed-by: Li Qiang <liq3ea@gmail.com>
Signed-off-by: Prasad J Pandit <pjp@fedoraproject.org>
Message-Id: <20200811114133.672647-7-ppandit@redhat.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
---

--- qemu-3.1+dfsg.orig/hw/misc/imx7_ccm.c
+++ qemu-3.1+dfsg/hw/misc/imx7_ccm.c
@@ -129,8 +129,16 @@ static const struct MemoryRegionOps imx7
     },
 };
 
+static void imx7_digprog_write(void *opaque, hwaddr addr,
+                                        uint64_t data, unsigned size)
+{
+    qemu_log_mask(LOG_GUEST_ERROR,
+                  "Guest write to read-only ANALOG_DIGPROG register\n");
+}
+
 static const struct MemoryRegionOps imx7_digprog_ops = {
     .read = imx7_set_clr_tog_read,
+    .write = imx7_digprog_write,
     .endianness = DEVICE_NATIVE_ENDIAN,
     .impl = {
         .min_access_size = 4,
--- qemu-3.1+dfsg.orig/hw/pci-host/designware.c
+++ qemu-3.1+dfsg/hw/pci-host/designware.c
@@ -20,6 +20,7 @@
 
 #include "qemu/osdep.h"
 #include "qapi/error.h"
+#include "qemu/log.h"
 #include "hw/pci/msi.h"
 #include "hw/pci/pci_bridge.h"
 #include "hw/pci/pci_host.h"
@@ -57,6 +58,23 @@ designware_pcie_root_to_host(DesignwareP
     return DESIGNWARE_PCIE_HOST(bus->parent);
 }
 
+static uint64_t designware_pcie_root_msi_read(void *opaque, hwaddr addr,
+                                              unsigned size)
+{
+    /*
+     * Attempts to read from the MSI address are undefined in
+     * the PCI specifications. For this hardware, the datasheet
+     * specifies that a read from the magic address is simply not
+     * intercepted by the MSI controller, and will go out to the
+     * AHB/AXI bus like any other PCI-device-initiated DMA read.
+     * This is not trivial to implement in QEMU, so since
+     * well-behaved guests won't ever ask a PCI device to DMA from
+     * this address we just log the missing functionality.
+     */
+    qemu_log_mask(LOG_UNIMP, "%s not implemented\n", __func__);
+    return 0;
+}
+
 static void designware_pcie_root_msi_write(void *opaque, hwaddr addr,
                                            uint64_t val, unsigned len)
 {
@@ -71,6 +89,7 @@ static void designware_pcie_root_msi_wri
 }
 
 static const MemoryRegionOps designware_pci_host_msi_ops = {
+    .read = designware_pcie_root_msi_read,
     .write = designware_pcie_root_msi_write,
     .endianness = DEVICE_LITTLE_ENDIAN,
     .valid = {
--- qemu-3.1+dfsg.orig/hw/pci-host/prep.c
+++ qemu-3.1+dfsg/hw/pci-host/prep.c
@@ -25,6 +25,7 @@
 
 #include "qemu/osdep.h"
 #include "qemu/units.h"
+#include "qemu/log.h"
 #include "qapi/error.h"
 #include "hw/hw.h"
 #include "hw/pci/pci.h"
@@ -116,8 +117,16 @@ static uint64_t raven_intack_read(void *
     return pic_read_irq(isa_pic);
 }
 
+static void raven_intack_write(void *opaque, hwaddr addr,
+                                        uint64_t data, unsigned size)
+{
+    qemu_log_mask(LOG_UNIMP, "%s not implemented\n", __func__);
+}
+
+
 static const MemoryRegionOps raven_intack_ops = {
     .read = raven_intack_read,
+    .write = raven_intack_write,
     .valid = {
         .max_access_size = 1,
     },
--- qemu-3.1+dfsg.orig/hw/ppc/prep_systemio.c
+++ qemu-3.1+dfsg/hw/ppc/prep_systemio.c
@@ -23,6 +23,7 @@
  */
 
 #include "qemu/osdep.h"
+#include "qemu/log.h"
 #include "hw/isa/isa.h"
 #include "exec/address-spaces.h"
 #include "qemu/error-report.h" /* for error_report() */
@@ -231,8 +232,15 @@ static uint64_t ppc_parity_error_readl(v
     return val;
 }
 
+static void ppc_parity_error_writel(void *opaque, hwaddr addr,
+                                    uint64_t data, unsigned size)
+{
+    qemu_log_mask(LOG_GUEST_ERROR, "%s: invalid access\n", __func__);
+}
+
 static const MemoryRegionOps ppc_parity_error_ops = {
     .read = ppc_parity_error_readl,
+    .write = ppc_parity_error_writel,
     .valid = {
         .min_access_size = 4,
         .max_access_size = 4,
--- qemu-3.1+dfsg.orig/hw/ppc/spapr_pci.c
+++ qemu-3.1+dfsg/hw/ppc/spapr_pci.c
@@ -49,6 +49,7 @@
 #include "sysemu/kvm.h"
 #include "sysemu/hostmem.h"
 #include "sysemu/numa.h"
+#include "qemu/log.h"
 
 /* Copied from the kernel arch/powerpc/platforms/pseries/msi.c */
 #define RTAS_QUERY_FN           0
@@ -752,6 +753,12 @@ static PCIINTxRoute spapr_route_intx_pin
     return route;
 }
 
+static uint64_t spapr_msi_read(void *opaque, hwaddr addr, unsigned size)
+{
+    qemu_log_mask(LOG_GUEST_ERROR, "%s: invalid access\n", __func__);
+    return 0;
+}
+
 /*
  * MSI/MSIX memory region implementation.
  * The handler handles both MSI and MSIX.
@@ -769,8 +776,11 @@ static void spapr_msi_write(void *opaque
 }
 
 static const MemoryRegionOps spapr_msi_ops = {
-    /* There is no .read as the read result is undefined by PCI spec */
-    .read = NULL,
+    /*
+     * .read result is undefined by PCI spec.
+     * define .read method to avoid assert failure in memory_region_init_io
+     */
+    .read = spapr_msi_read,
     .write = spapr_msi_write,
     .endianness = DEVICE_LITTLE_ENDIAN
 };
--- qemu-3.1+dfsg.orig/hw/vfio/pci-quirks.c
+++ qemu-3.1+dfsg/hw/vfio/pci-quirks.c
@@ -12,6 +12,7 @@
 
 #include "qemu/osdep.h"
 #include "qemu/units.h"
+#include "qemu/log.h"
 #include "qemu/error-report.h"
 #include "qemu/main-loop.h"
 #include "qemu/range.h"
@@ -274,8 +275,15 @@ static uint64_t vfio_ati_3c3_quirk_read(
     return data;
 }
 
+static void vfio_ati_3c3_quirk_write(void *opaque, hwaddr addr,
+                                        uint64_t data, unsigned size)
+{
+    qemu_log_mask(LOG_GUEST_ERROR, "%s: invalid access\n", __func__);
+}
+
 static const MemoryRegionOps vfio_ati_3c3_quirk = {
     .read = vfio_ati_3c3_quirk_read,
+    .write = vfio_ati_3c3_quirk_write,
     .endianness = DEVICE_LITTLE_ENDIAN,
 };
 
